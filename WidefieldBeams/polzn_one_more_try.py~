import numpy as np
import healpy as hp
import pylab as plt
from cst2hp import cst2hp
from rotate_healpix_map import rotate_healpix_map as rotmap
plt.rc('text', usetex=True)
plt.rc('font', family='serif')

def Orth(map):
    hp.orthview(map,half_sky=True)
    return

"""Point the beam at the equator to

1) make use of the fact that we know a z-oriented dipole only has
theta-hat field, so the phi-hat is identically zero.

2) correspondingly, the y-dipole is clearly all phi-hat in the
equatorial plane, and only slowly deviates as you leave the equator

2) Avoid the weird singularities at the pole.  I really want this to
not suffer from numerical defects

"""

# This should be wrapped up in a map object
nside = 256
npix = hp.nside2npix(nside)
ipix = np.arange(npix)
theta,phi = hp.pix2ang(nside,ipix)

D_z = np.sin(theta) # Actual dipole power response for z-oriented dipole
D_y = rotmap(rotmap(D_z,[0,90]),[90,0])
apod = rotmap(np.exp(-np.power(theta,2)),[0,-90])
#np.ones(npix) #

#Orth(apod)
#hp.graticule()
#plt.show()

# OK, coordinate system.  "x" here denotes dipole along z, with beam
# directed towards the +x axis.  "y" is actually along the y axis, but
# the beam is still oriented towards +x

#xnorm = np.power(1-np.power(np.sin(theta)*np.cos(phi),2),-0.5)
#Axt = xnorm * np.cos(theta) * np.cos(phi)
#Axp = xnorm * (-1.) * np.sin(phi)
Axt = apod * D_z #apod
Axp = np.zeros(npix)
ynorm = np.power(1-np.power(np.sin(theta)*np.sin(phi),2),-0.5)
Ayt = apod * D_y * ynorm * np.cos(theta) * np.sin(phi)
Ayp = apod * D_y * ynorm * np.cos(phi)

A = np.array([[Axt,Axp],[Ayt,Ayp]])

# Now follow the algebra
AA = np.zeros([4,4,npix],dtype='complex64')
nom_vis = np.zeros([4,4,npix],dtype='complex64')

S = 1./2*np.array([[1.,1,0,0],[0,0,1,1j],[0,0,1,-1j],[1,-1,0,0]])
Sinv = np.array([[1.,0,0,1],[1,0,0,-1],[0,1,1,0],[0,-1j,1j,0]])

for i in range(npix):
    J = A[:,:,i]
    AA[:,:,i] = np.kron(J,J)
    nom_vis[:,:,i] = np.dot(Sinv,np.dot(AA[:,:,i],S)) 

nom_vis = nom_vis.real

